import java.io.Serializable;
import java.math.BigDecimal;

/**
 * @author xiangyuan.ni
 */
public class CommonRequest<T> implements Serializable {

    /**
     * requestNo:生成规则userid+yyyyMMddHHmmssSSS，前端传给后台
     */
    private String requestNo;

    private T param;

    public String getRequestNo() {
        return requestNo;
    }

    public void setRequestNo(String requestNo) {
        this.requestNo = requestNo;
    }

    public T getParam() {
        return param;
    }

    /**
     * 内存区域详解：https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F?id=java-%e5%86%85%e5%ad%98%e5%8c%ba%e5%9f%9f%e8%af%a6%e8%a7%a3
     * 虚拟内存：https://juejin.cn/post/6844903507594575886
     * JVM 常量池中存储的是对象还是引用：https://www.zhihu.com/question/57109429/answer/151717241
     * 进程间通信IPC：https://www.jianshu.com/p/c1015f5ffa74
     * 多级页表如何节约内存：https://www.polarxiong.com/archives/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98.html
     * @param param
     */
    public void setParam(T param) {
        this.param = param;
    }

    /**
     * 操作系统
     *
     * 进程间通信
     * Pipes：管道/匿名管道： 父子进程或兄弟进程
     * Names Pipes：有名管道：队列是->先进先出,实现本机任意两个进程通信
     * Signal：信号：用于通知进程某个事件已经发生
     * Message Queuing：消息队列：是消息的链表，在内存中，不一定是先进先出？？。
     *      好处：Signal承载信息少，Pipes只能承载无格式字节流以及缓冲区大小受限
     *      Pipes:只存在内存中
     *      Names Pipes:存在于实际的磁盘介质或文件系统
     *      Message Queuing：存在内核中(只有内核重启->操作系统重启，才能显式删除一个消息队列)
     * Semaphores：信号量：是一个计数器，用于多进程对共享数据的访问。目的是为了解决同步、避免竞争条件
     * Shared memory：共享内存：最有效的进程间通信，使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程对共享内存中的共享数据更新。不过需要同步操作，如互斥锁和Semaphores
     * Sockets：套接字：用于客户端和服务端之间通过网络进行通信
     *
     * 线程间通信
     * Mutex：互斥量：只有拥有互斥对象的线程才有访问公共资源的权限。可以保证公共资源不会被多个线程同时访问。如synchronized和Lock都是这种机制
     * Semaphores：信号量：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。
     * Event：事件：Wait/Notify：通过通知操作的方式来保持多线程同步
     *
     * 进程的调度算法：确定首先执行哪个进程以及最后执行哪个进程以实现最大CPU利用率
     * FCFS：先到先服务调度算法：从就绪队列选择一个最先进入该队列的进程为之分配资源，一直执行或者发生某事件被阻塞而废弃占用
     * SJF：短作业优先调度算法：选择一个估计运行时间最短的进程为之分配资源。
     * Round robin：RR调度：时间片轮转调度算法：是一种最古老、最简单、最公平和使用最广的算法。每个进程被分配一个时间段，称作他的时间片，即该进程运行时间
     * 多级反馈队列调度算法：公认较好的进程调度算法，Unix就是使用此算法，既能使高优先级的作业得到响应又能使短作业迅速完成
     *      SJF：仅照顾短进程而忽略长进程
     * 优先级调度：首先执行具有最高优先级的进程。有相同优先级的进程以FCFS方式执行。
     *
     * 操作系统内存管理基础
     *
     * 内存管理介绍：操作系统的内存管理主要负责内存的分配和回收(malloc函数：申请内存，free函数：释放内存)，地址转换->将逻辑地址转换成相应的物理地址等功能
     * 常见的内存管理机制：
     *      连续分配管理方式：指为一个用户程序分配一个连续的内存空间，如：块式管理
     *          块式管理：很久之前计算机操作系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大部分被浪费了，这些在每个块中未被利用的空间，称为碎片。
     *      非连续分配管理方式：允许一个程序使用的内存发布在离散或不相邻的内存中。如：页式管理、段式管理、段页式管理机制
     *          页式管理：把主存分为大小相等且固定的一页一页的形式，页较小，相对于块式管理的划分粒度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址
     *          段式管理：页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多。但是，最重要的是段是有实际意义的，每个段定义了一组逻辑信息。例如：有主程序段MAIN、子程序段X、数据段D及栈段S等。段式管理通过段表对应逻辑地址和物理地址
     *          段页式管理：结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说：段页式管理机制中段与段之间以及段的内部的都是离散的
     * 快表和多级页表：为了解决页表管理中的两个问题：1.虚拟地址到物理地址的转换要快；2.解决虚拟地址空间大，页表也会很大的问题。
     *      为了提高内存的空间性能，提出了多级页表的概念；但是提高空间性能是以浪费时间性能为基础的。因此为了补充损失的时间性能，提出了快表(TLB)的概念。不论是快表还是多级页表实际上都利用到了程序的"局部性原理"。
     *      快表：为了解决虚拟地址到物理地址的转换速度，操作系统在 页表方案 基础上引入了 快表来加速虚拟内存到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器(Cache),其中的内容是页表的一部分或者全部内容。作为页表的Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时CPU要访问两次主存。有了快表有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。
     *          使用流程(特别像redis)：
     *          根据虚拟地址中的页号查快表
     *          如果该页在快表中，直接从快表中读取相应的物理地址
     *          如果不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中。
     *          当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页
     *      多级页表：引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中，多级页表属于时间换空间的典型场景
     * 分页机制和分段机制的共同点和区别：
     *      共同点：
     *          分页机制和分段机制都是为了提高内存利用率，减少内存碎片
     *          页和段都是离散存储的，所以两者都是离散分配内存的方式。但是每个页和段中的内存是连续的
     *      不同点：
     *          页的大小是固定的，由操作系统决定；段的大小不固定，取决于我们当前运行的程序
     *          分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段、数据段、能够更好满足用户的需要
     * 逻辑(虚拟)地址和物理地址：我们编程一般只有可能和逻辑地址打交道，比如在C语言中，指针里面存储的数值就可以理解为内存里的一个地址，这个地址就是逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中的地址，更具体一点来说就是内存地址寄存器中的地址，物理地址是内存单元真正的地址。
     * CPU寻址：现在处理器使用的是一种称为虚拟寻址(Virtual Addressing)的寻址方式。使用虚拟寻址，CPU需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。实际上完成虚拟地址转换为物理地址转换的硬件是CPU中含有一个被称为内存管理单元(Memory Management Unit, MMU)
     * 为啥需要虚拟地址空间：如果没有虚拟地址空间的时候，程序都是直接访问和操作的都是物理内存。
     *      如果没有的坏处：
     *          用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易破坏操作系统，造成操作系统崩溃
     *          想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个QQ音乐都不行。例如：微信在运行的时候给内存地址1XXX赋值后，QQ音乐也同样给内存地址1XXX赋值，那么QQ音乐对内存的赋值就会覆盖微信之前所赋的值，那么微信就会奔溃
     *      有的好处：
     *          程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区
     *          程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变少，内存管理器会将物理内存页(通常大小为4KB)保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。
     *          不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在又另一个进程或操作系统使用的物理内存
     *
     * 虚拟内存(Virtual Memory)
     * 虚拟内存：
     *      在我们使用的Windows系统时，我们点开了很多占内存的软件，这些软件占用的内存远远超过我们电脑本身具有的物理内存。就是因为虚拟内存的存在，通过虚拟内存可以让程序可以拥有超过系统物理内存大小的可用内存空间。另外，虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉
     *      虚拟内存是计算机系统内存管理的一种技术，我们可用手动设置自己电脑的虚拟内存。不要单纯认为虚拟内存只是"使用硬盘空间来扩展内存"的技术。虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且把内存扩展到硬盘空间
     *      虚拟内存使得应用程序认为它拥有连续的可用的内存(一个连续完整的地址空间)，而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存(例如RAM)的使用也更有效率。目前大多数操作系统都使用了虚拟内存，如Windows家族的"虚拟内存"；Linux的"交换空间"
     * 局部性原理：局部性原理即适用于程序结构，也适用于数据结构
     *      局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。
     *      早在1968年的时候，就有人指出我们的程序在执行的时候往往呈现局部性规律，也就是说在某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。
     *      表现在两个方面：
     *          虚拟内存技术实际上就是建立了"内存-外存"的两级存储器的结构，利用局部性原理实现高速缓存。
     *          时间局限性：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局限性的典型原因，是由于在程序中存在着大量的循环操作。
     *                    时间局部性是通过将近来使用的指令和数据保存到告诉缓存存储器中，并使用高速缓存的层次结构实现。
     *          空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的
     *                    空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。
     * 虚拟存储器：虚拟存储器又叫虚拟内存，都是Virtual Memory的翻译
     *      基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存中时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大的多的存储器-虚拟存储器。
     *      实际上，虚拟内存也是一种时间换空间的策略，程序世界不是时间换空间就是空间换时间。
     *
     * 虚拟内存的实现技术：需要建立离散分配到内存管理方式的基础上，有3种方式
     *      请求分页和分页存储管理的区别：
     *          请求分页存储管理建立分页管理之上。它们根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因。
     *          它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理"不要求"将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚拟内存，而分页存储管理却不能提供虚存。
     *          不论是哪种实现方式，我们都需要：
     *              一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了
     *              缺页中断：如果需执行的指令或访问的数据尚未在内存(称为缺页或缺段)，则由处理器通知操作系统将相应的页面或段调入到内存，然后后续执行程序。
     *              虚拟地址空间：逻辑地址到物理地址的变换
     *      请求分页存储管理：最常用。建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调用功能和页面置换功能。请求分页管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。
     *      请求分段存储管理：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段存储管理方式就如同请求分页存储管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。
     *      请求段页式存储管理：
     *
     * 页面置换算法：
     *      地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断(要访问的页不在主存，需要操作系统将其调入主存后再进行访问。在这个时候，被内存映射的文件实际上成了一个分页交换文件)。
     *      当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面认出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。
     *      OPT页面置换算法(最佳页面置换算法)：最佳(Optimal,OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若干页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法
     *      FIFO(First In First Out)页面置换算法(先进先出页面置换算法)：总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。
     *      LRU(Least Currently Used)页面置换算法(最近最久未使用页面置换算法)：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间T，当必须淘汰一个页面时，选择现有页面中其T值最大的，即最近最久未使用的页面予以淘汰
     *      LFU(Least Frequently Used)页面置换算法(最少使用页面置换算法)：该置换算法选择在之前时期使用最少的页面作为淘汰页。
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     */
    private BigDecimal invoicesTotalAmount;

    private BigDecimal withdrawAmount;

    // 注意: 在新建该对象时，如果对象没有关联不能将balance设置为0，
    // 0表示已经关联但发票金额和提现记录差额为0，
    // null表示没有关联，未设置差额
    private BigDecimal balance;

    private Long userId;

    private String userName;
}
